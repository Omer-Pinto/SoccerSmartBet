# SoccerSmartBet Database Schema Documentation

**Version:** 1.0  
**RDBMS:** PostgreSQL 14+

---

## Overview

The SoccerSmartBet database schema supports a **non-monetary AI soccer betting system** with four main application flows:

1. **Pre-Gambling Flow**: Daily game selection, data fetching, AI report generation
2. **Gambling Flow**: User and AI bet collection
3. **Post-Games Flow**: Results fetching and P&L calculation
4. **Offline Analysis Flow**: Historical analytics and statistics

### Core Tables

| Table | Purpose |
|-------|---------|
| `teams` | Master data for football teams |
| `games` | Daily match fixtures with processing status |
| `betting_lines` | Odds from winner.co.il (Israeli Toto) |
| `game_reports` | AI-generated game analysis (Game Intelligence Agent) |
| `team_reports` | AI-generated team analysis (Team Intelligence Agent) |
| `bets` | User and AI predictions (single bets, 100 NIS stake) |
| `results` | Match results and P&L calculations |

---

## Key Design Decisions

### 1. UUID Primary Keys for Parallel Writes

**Problem:** Pre-Gambling Flow runs parallel subgraphs:
- N Game Intelligence Agents writing to `game_reports`
- 2N Team Intelligence Agents writing to `team_reports` (home + away)

**Solution:**
- `game_reports.report_id` = UUID (not SERIAL)
- `team_reports.report_id` = UUID (not SERIAL)

**Benefit:** Agents generate unique IDs client-side, avoiding database sequence contention during parallel writes.

### 2. Status Enum for Game Processing

The `games.status` column tracks each game through all flows:

| Status | Description |
|--------|-------------|
| `pending` | Initial state after Smart Game Picker selection |
| `selected` | Passed odds filter from winner.co.il |
| `filtered` | Did not meet minimum odds threshold |
| `processing` | Reports being generated by agents |
| `ready_for_betting` | Reports completed, ready for Gambling Flow |
| `betting_open` | User/AI can place bets |
| `betting_closed` | Deadline passed |
| `in_progress` | Match started |
| `completed` | Match finished, results available |
| `cancelled` | Match cancelled (weather, etc.) |

### 3. Israeli Toto Notation

Betting lines use winner.co.il notation:
- `n1` = Home win odds
- `n2` = Away win odds  
- `n3` = Draw odds

**Note:** This differs from standard 1/X/2 ordering.

### 4. AI-Generated Injury Analysis (No Player Roster)

Team Intelligence Agent stores injury information as AI-generated TEXT in `team_reports.injury_impact`, eliminating the need for a separate `players` table.

**Example:** "Critical starters missing: Benzema (striker), Mendy (LB)" vs "Minor depth issues: backup goalkeeper out"

### 5. Essential Indexes Only

Indexes focus on:
- Primary keys (automatic)
- Foreign keys for JOINs
- Frequently queried columns: `games(match_date, status)`, `team_reports(game_id, team_id)`

Additional indexes can be added later when queries demonstrate need.

### 6. Fixed Stake Constraint

`bets.stake` has a CHECK constraint enforcing exactly 100.00 NIS per system rules:

```sql
CONSTRAINT fixed_stake CHECK (stake = 100.00)
```

### 7. P&L Calculation

Results table stores computed profit/loss:
- **Win:** `pnl = stake × odds - stake` (e.g., 100 × 2.10 - 100 = 110 NIS profit)
- **Loss:** `pnl = -stake` (e.g., -100 NIS)

---

## Relationships

- **teams → games** (1:N): One team plays in many games
- **games → betting_lines** (1:N): Historical odds tracking
- **games → game_reports** (1:1): One AI report per game
- **games → team_reports** (1:2): Two reports per game (home + away)
- **games → bets** (1:2): Up to 2 bets per game (user + AI)
- **games → results** (1:1): One result per game

---

## Quick Reference

### Create Application Role

```sql
CREATE ROLE soccersmartbet_app WITH LOGIN PASSWORD 'secure_password';
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO soccersmartbet_app;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO soccersmartbet_app;
```

### Fetch Complete Report for a Game

```sql
SELECT 
    g.game_id,
    ht.name AS home_team,
    at.name AS away_team,
    bl.n1, bl.n2, bl.n3,
    gr.h2h_insights,
    tr_home.form_trend AS home_form,
    tr_away.injury_impact AS away_injuries
FROM games g
JOIN teams ht ON g.home_team_id = ht.team_id
JOIN teams at ON g.away_team_id = at.team_id
LEFT JOIN betting_lines bl ON g.game_id = bl.game_id
LEFT JOIN game_reports gr ON g.game_id = gr.game_id
LEFT JOIN team_reports tr_home ON g.game_id = tr_home.game_id AND g.home_team_id = tr_home.team_id
LEFT JOIN team_reports tr_away ON g.game_id = tr_away.game_id AND g.away_team_id = tr_away.team_id
WHERE g.game_id = $1;
```

### User vs AI Performance

```sql
SELECT 
    COUNT(*) AS total_games,
    SUM(CASE WHEN user_pnl > 0 THEN 1 ELSE 0 END) AS user_wins,
    SUM(CASE WHEN ai_pnl > 0 THEN 1 ELSE 0 END) AS ai_wins,
    SUM(user_pnl) AS user_total_pnl,
    SUM(ai_pnl) AS ai_total_pnl
FROM results;
```

---

**Next Steps:**
1. Deploy to staging via Docker Compose (Task 1.4)
2. Implement database access layer in Python (SQLAlchemy or psycopg2)
3. Write queries in Python when needed (avoid premature SQL views)
4. Add indexes later if queries prove slow
